- 本教程视频链接地址：https://www.bilibili.com/video/av81497003/

- 本教程gitee上地址：https://gitee.com/advance/tutorial-laravel

- 本教程github上地址：https://github.com/youshengyouse/tutorial-laravel

  

##  ![laravel_002_a](./imgs_tutorials/laravel_002_a.jpg)



##  项目结构

```
|-- app*  应用目录，应用的主要代码，象框架的集成扩展，Controller,Model,ServiceProvider,MiddleWare等
|-- bootstrap* 启动目录，包括app.php，cache目录必须是可写的，用来放启动时优化性能的一些生成文件,如packages.php，services.php
|-- config* 包含所有配置文件。先过一遍，了解项目中会用到哪些配置,从数据库读取的配置没有放在这里
|-- database** 数据库,数据库填充、迁移、模型工厂文件
|-- public* 公共目录，只有这个目录里的内容，用户是可以访问的,放css,js,图片等静态资源及入口文件index.php
|-- resources* 资源目录,未编译的源文件（模板、语言包、sass,js,less等）
|-- routes 路由目录
|-- storage** 储存目录,必须是可写的，编译好的模板文件，session 文件，缓存文件，日志等文件
|-- tests 单元测试
|-- vendor 第三方包,composer安装的包都放在这里
|-- artisan console应用的入口文件
|-- CHANGELOG.md
|-- composer.json
|-- composer.lock
|-- LICENSE
|-- package.json
|-- phpunit.xml
|-- README.md
|-- server.php
|--webpack.mix.js
带*的目录表示用相应的Getter方法
带**的目录表示用相应的Setter和Getter方法
```

## Laravel框架结构

```
|-- Auth
|-- Broadcasting
|-- Bus
|-- Cache
|-- Config
|-- Console
|-- Container
|-- Contracts  接口
|-- Cookie
|-- Database
|-- Encryption
|-- Events
|-- Filesystem
|-- Foundation 专门laravel框架定制
|-- Hashing
|-- Http
|-- Log
|-- Mail
|-- Notifications
|-- Pagination
|-- Pipeline
|-- Queue
|-- Redis
|-- Routing
|-- Session
|-- Support 辅助支持
|-- Translation
|-- Validation
|-- View

```




## 10个路径
| 路径                 | 设置方法                              | $app中获取方法                                  | 容器中获取方法         | 助手方法                       |
| -------------------- | ------------------------------------- | ----------------------------------------------- | ---------------------- | ------------------------------ |
| 基本 basePath        | 应用构造函数或 setBasePath($basePath) | basePath($path = '')                            | $app['path.base']      | base_path                      |
| 应用 path            | 无                                    | path($path = '')  默认为 基本/app               | $app['path']           | app_path                       |
| 启动 bootstrapPath   | 无                                    | bootstrapPath($path = '') 默认为 基本/bootstrap | $app['path.bootstrap'] |                                |
| 配置 configPath      | 无                                    | configPath($path = '') 默认为 基本/config       | $app['path.config']    | config_path                    |
| 前端 publicPath      | 无                                    | publicPath() 默认为 基本/public √               | $app['path.public']    | public_path(‘子目录’)这里不同  |
| 资源 resourcePath    | 无                                    | resourcePath($path = '') 默认为 基本/resource   | $app['path.resource']  | resource_path                  |
| 语言 langPath        | 无，                                  | langPath() 默认为 资源路径/lang                 | $app['path.lang']      |                                |
| 储存 storagePath     | useStoragePath($path)                 | storagePath() 默认为 基本/storage               | $app['path.storage']   | storage_path('子目录')这里不同 |
| 数据库 databasePath  | useDatabasePath($path)                | databasePath($path = '') 默认为 基本/database √ | $app['path.database']  | database_path                  |
| 环境 environmentPath | useEnvironmentPath($path)             | environmentPath(),默认是基本路径                | 无                     |                                |

- 获取路径的方法有如下5种
  
   - $app->get('path.database')
   - $app->make('path.database')
   - $app['path.database']
   - $app->databasePath('可含子目录或文件')
   - database_path('可含子目录或文件')，**推荐使用这种**
   
   一定要记住，只会生成一个目录或文件路径**字符串，并不会判断是否存在**
   
- 建议使用**助手函数**来获取路径，尤其是public_path和storage_path路径，$app中的方法是无法指定子目录,但助手可 以。

  - 例子：base_path('routes/web.php')
  - 例子：config_path('flare.php')的值为 
  - 例子：file_put_contents(app_path('Http/Controllers/HomeController.php'),'替换Home控制器')
  - 例子：$filesystem->deleteDirectory(<u>*public_path*</u>('css')
  - 例子：resource_path('views/vendor/mail')
  - 例子：*<u>storage_path</u>*('framework/views')
  
- databasePath、storagePath 和 basePath是可以在应用实例化后再指定的。换句话只有这3种可以设定，其它的目录都是只读的。(另外环境目录也可以设置，但一般不考虑)

- 环境路径一般也不用设，除非有很多种环境，那样将所有的环境文件都放到环境路径下

- abcpr这5个目录是basePath的子目录，资源路径的名字为resource，配置目录名字是config，这种写死的方法，方便所用框架用户一眼就明白哪个目录是做什么用的。但缺点是灵活度不够，如果想修改，在Application继承类中重构。

- 在实际中工作，可能还得有其它的路径，如扩展，模块等，得在继承类中定义

- 路由`routes`是单独一个目录，但没有相应的方法来指定或获取，一般放在基本目录下，读取相应文件是`base_path('routes/web.php')`

- 如果是多个项目，如项目aaaa,项目bbbb，那么基本路径就得另指定，相应的a,b,c,p,r都要移动其下面

- 如果一个应用，比如CMS系统，有用户模块，文章模块，媒体模块，<u>如何搭建项目结构，大家思考下</u>，一般建议写成单独的包，最后安装到vendor中

## 第一个控制器

```
# \Illuminate\Routing\Console\ControllerMakeCommand
# 待改进的地方有，象yii一样可以同时生成方法名
# 现只能将生成的控制器文件放到/App/Http/Contollers下面
php artisan make:controller ProductController
php artisan make:controller Admin/ProductController
```

## 第一个模型

```
php artisan make:model Product
php artisan make:model Models/Product
```
## 第一条路由
```
Route::get('/', 'ProductController@list-products');
```
## 第一个视图

```php
//0000_laravel/resources/views/product/list-products.blade.php
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<table>
    <?php
    foreach($results as $product) {
        //print_r(array_values($product));
        //list($id,$title,$views)  = array_values($product);
        //printf("<tr><td> %s </td><td> %s </td><td> %s </td>",$id,$title,$views);
        [$a,$b,$c]  = array_values($product);
        printf("<tr><td> %s </td><td> %s </td><td> %s </td>",$a,$b,$c);
        //printf("<tr><td> %s </td><td> %s </td><td> %s </td>",...array_values($product));
    }
    ?>
</table>
</body>
</html>
```



# 给我来杯“茶颜悦色”

![pay](./imgs_tutorials/pay.jpg)